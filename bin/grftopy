#!/usr/bin/env python

from pathlib import Path
import re
import sys
import struct
import unicodedata
from nml import lz77

import grf
from grf.common import hex_str, utoi8, DataReader, read_extended_byte, read_dword, read_word
from grf.va2vars import VA2_VARS_INV
from grf.parser import OP_INIT, SPRITE_FLAGS
from grf.actions import ACTION0_PROPS, SpriteRef, Property


RESOURCE_FOLDER = 'resources'


def str_sprite(sprite):
    sprite_id = sprite & 0x1fff
    draw = {0: 'N', 1 : 'T', 2: 'R'}[(sprite >> 14) & 3]
    color_translation = (sprite >> 16) & 0x3fff
    normal_in_transparent = bool(sprite & (1 << 30))
    sprite_type = sprite >> 31
    ntstr = ['', ' NF'][normal_in_transparent]
    return f'[{sprite_id} {draw}{ntstr} {color_translation}-{sprite_type}]'


RESOURCES = set()


def find_unique_resource_name(name, extension, tries=100):
    global RESOURCES
    for i in range(tries):
        if i == 0:
            unique = (name + '.' + extension)
        else:
            unique = (name + f'_{i + 1}.' + extension)

        if unique not in RESOURCES:
            RESOURCES.add(unique)
            return unique

    raise RuntimeError(f'Exceeded the limit of {tries} tries trying to create unique resource name for "{name}"')


def write_resource(name, extension, data, tries=100):
    folder = Path(RESOURCE_FOLDER)
    folder.mkdir(parents=True, exist_ok=True)

    # cut extension if it's already in the name
    if name.endswith('.' + extension):
        name = name[-len(extension) - 1:]

    # generate safe filename
    name = unicodedata.normalize('NFKD', name).encode('ascii', 'ignore').decode('ascii')
    name = re.sub(r'[^\w\s-]', '', name.lower())
    name = re.sub(r'[-\s]+', '-', name).strip('-_')

    name = find_unique_resource_name(name, extension, tries=tries)
    open(folder / name, 'wb').write(data)


def read_property(data, ofs, fmt):
    if not isinstance(fmt, str):
        assert callable(fmt), fmt
        return fmt(data, ofs)

    if fmt == 'B':
        return data[ofs], ofs + 1

    if fmt == 'W':
        return data[ofs] | (data[ofs + 1] << 8), ofs + 2

    if fmt == 'L':
        return data[ofs: ofs + 4], ofs + 4

    if fmt == 'D':
        return read_dword(data, ofs)

    if fmt == 'B*':
        return read_extended_byte(data, ofs)

    if fmt == 'n*B':
        n = data[ofs]
        return data[ofs + 1: ofs + 1 + n], ofs + 1 + n

    if fmt == 'n*L':
        n = data[ofs]
        res = [data[ofs + 1 + i * 4: ofs + 1 + i * 4 + 4] for i in range(n)]
        return res , ofs + 1 + n * 4

    if fmt == '3*B':
        return (data[ofs], data[ofs + 1], data[ofs + 2]), ofs + 3

    if fmt == '2*L':
        return (data[ofs: ofs + 4], data[ofs + 4: ofs + 8]), ofs + 8

    if fmt == 'n*m*W':
        d = DataReader(data, ofs)
        n = d.get_byte()
        m = d.get_byte()
        res = []
        for _ in range(n):
            res.append([d.get_word() for _ in range(m)])
        return res, d.offset

    if fmt == '(BV)+':
        res = {}
        while data[ofs] != 0:
            name_end = data.find(b'\0', ofs + 1)
            res[data[ofs]] = data[ofs + 1: name_end]
            ofs = name_end + 1
        return res, ofs + 1

    if fmt == 'n*(BB)':
        num = data[ofs]
        res = ((data[ofs + 2 * i + 1], data[ofs + 2 * i + 2]) for i in range(num))
        return res, ofs + 2 * num + 1

    if fmt == 'Layouts':
        d = DataReader(data, ofs)
        num = d.get_byte()
        size = d.get_dword()
        res = []
        for _ in range(num):
            for k in range(size):  # effectively infinite loop
                xofs = d.get_byte()
                yofs = d.get_byte()
                if xofs == 0xfe and k == 0:
                    # borrow base layout
                    raise NotImplementedError

                if xofs == 0 and yofs == 0x80:
                    break

                gfx = d.get_byte()
                if gfx == 0xfe:
                    local_tile_id = d.get_word()
                    gfx = f'todo_ref({local_tile_id})'
                elif gfx == 0xff:
                    xofs = utoi8(xofs & 0xff)
                    yofs = utoi8(yofs & 0xff)
                    gfx = None

                res.append({
                    'xofs': xofs,
                    'yofs': yofs,
                    'gfx': gfx,
                })

        return res, d.offset

    raise ValueError(fmt)


def decode_action0(data):
    feature = grf.Feature(data[0])
    num_props = data[1]
    num_info = data[2]
    first_id, ofs = read_extended_byte(data, 3)
    props = {}
    for _ in range(num_props):
        prop = data[ofs]
        ofs += 1
        propdict = ACTION0_PROPS[feature]
        name, fmt, *_ = propdict[prop]
        if num_info == 1:
            try:
                value, ofs = read_property(data, ofs, fmt)
            except ValueError:
                raise RuntimeError(f'No reader for property {name} format {fmt}')
            props[name] = value
        else:
            res = []
            for _ in range(num_info):
                value, ofs = read_property(data, ofs, fmt)
                res.append(value)
            props[name] = res

    if num_info == 1:
        return [grf.Define(
            feature=feature,
            id=first_id,
            props=props,
        )]
    else:
        return [grf.DefineMultiple(
            feature=feature,
            first_id=first_id,
            count=num_info,
            props=props,
        )]


def decode_action1(data):
    sprite_count, _ = read_extended_byte(data, 2)
    feature = grf.Feature(data[0])
    set_count = data[1]
    if set_count == 1:
        return [grf.SpriteSet(
            feature=feature,
            sprite_count=sprite_count
        )]
    else:
        return [grf.Action1(
            feature=feature,
            set_count=set_count,
            sprite_count=sprite_count
        )]


SPRITE_GROUP_OP = [
    'ADD',   # a + b
    'SUB',   # a - b
    'SMIN',  # (signed) min(a, b)
    'SMAX',  # (signed) max(a, b)
    'UMIN',  # (unsigned) min(a, b)
    'UMAX',  # (unsigned) max(a, b)
    'SDIV',  # (signed) a / b
    'SMOD',  # (signed) a % b
    'UDIV',  # (unsigned) a / b
    'UMOD',  # (unsigned) a & b
    'MUL',   # a * b
    'AND',   # a & b
    'OR',    # a | b
    'XOR',   # a ^ b
    'STO',   # store a into temporary storage, indexed by b. return a
    'RST',   # return b
    'STOP',  # store a into persistent storage, indexed by b, return a
    'ROR',   # rotate a b positions to the right
    'SCMP',  # (signed) comparison (a < b -> 0, a == b = 1, a > b = 2)
    'UCMP',  # (unsigned) comparison (a < b -> 0, a == b = 1, a > b = 2)
    'SHL',   # a << b
    'SHR',   # (unsigned) a >> b
    'SAR',   # (signed) a >> b
]


# TLF_NOTHING           = 0x00
# TLF_DODRAW            = 0x01  # Only draw sprite if value of register TileLayoutRegisters::dodraw is non-zero.
# TLF_SPRITE            = 0x02  # Add signed offset to sprite from register TileLayoutRegisters::sprite.
# TLF_PALETTE           = 0x04  # Add signed offset to palette from register TileLayoutRegisters::palette.
# TLF_CUSTOM_PALETTE    = 0x08  # Palette is from Action 1 (moved to SPRITE_MODIFIER_CUSTOM_SPRITE in palette during loading).
# TLF_BB_XY_OFFSET      = 0x10  # Add signed offset to bounding box X and Y positions from register TileLayoutRegisters::delta.parent[0..1].
# TLF_BB_Z_OFFSET       = 0x20  # Add signed offset to bounding box Z positions from register TileLayoutRegisters::delta.parent[2].
# TLF_CHILD_X_OFFSET    = 0x10  # Add signed offset to child sprite X positions from register TileLayoutRegisters::delta.child[0].
# TLF_CHILD_Y_OFFSET    = 0x20  # Add signed offset to child sprite Y positions from register TileLayoutRegisters::delta.child[1].
# TLF_SPRITE_VAR10      = 0x40  # Resolve sprite with a specific value in variable 10.
# TLF_PALETTE_VAR10     = 0x80  # Resolve palette with a specific value in variable 10.
# TLF_KNOWN_FLAGS       = 0xFF  # Known flags. Any unknown set flag will disable the GRF.

# # /** Flags which are still required after loading the GRF. */
# TLF_DRAWING_FLAGS     = ~TLF_CUSTOM_PALETTE

# # /** Flags which do not work for the (first) ground sprite. */
# TLF_NON_GROUND_FLAGS  = TLF_BB_XY_OFFSET | TLF_BB_Z_OFFSET | TLF_CHILD_X_OFFSET | TLF_CHILD_Y_OFFSET

# # /** Flags which refer to using multiple action-1-2-3 chains. */
# TLF_VAR10_FLAGS       = TLF_SPRITE_VAR10 | TLF_PALETTE_VAR10

# # /** Flags which require resolving the action-1-2-3 chain for the sprite, even if it is no action-1 sprite. */
# TLF_SPRITE_REG_FLAGS  = TLF_DODRAW | TLF_SPRITE | TLF_BB_XY_OFFSET | TLF_BB_Z_OFFSET | TLF_CHILD_X_OFFSET | TLF_CHILD_Y_OFFSET

# # /** Flags which require resolving the action-1-2-3 chain for the palette, even if it is no action-1 palette. */
# TLF_PALETTE_REG_FLAGS = TLF_PALETTE

def read_sprite_layout_registers(d, flags, is_parent):
    # regs = {'flags': flags & TLF_DRAWING_FLAGS}
    regs = {}
    for flag, (fparent, mask, size, conversion) in SPRITE_FLAGS.items():
        if flags & mask == 0:
            continue
        if fparent is not None and fparent != is_parent:
            continue

        if size == 0:
            value = True
        elif size == 1:
            value = d.get_byte()
        elif size == 2:
            value = (d.get_byte(), d.get_byte())
        else:
            raise RuntimeError(f'Incorrect size of sprite register {flag}: {size}')

        if conversion:
            value = conversion(value)
        regs[flag] = value

    return regs


def read_sprite_layout(d, feature, ref_id, num, basic_format):
    assert feature in (grf.HOUSE, grf.INDUSTRY_TILE, grf.OBJECT, grf.INDUSTRY), feature

    # TODO a lot of duplicate code with read_sprite_layout in actions.py
    has_z_position = not basic_format
    has_flags = bool(num & 0x40)
    num &= 0x3f

    def read_sprite():
        sprite = d.get_dword()
        flags = d.get_word() if has_flags else 0
        return SpriteRef.from_grf(sprite), flags

    ground_sprite, ground_flags = read_sprite()
    ground = {'sprite': ground_sprite}
    ground.update(read_sprite_layout_registers(d, ground_flags, False))
    sprites = []
    for _ in range(num):
        sprite, flags = read_sprite()
        seq = {'sprite': sprite}
        offset = (d.get_byte(), d.get_byte(), d.get_byte() if has_z_position else 0)
        is_parent = (offset[2] != 0x80)
        if is_parent:
            seq['offset'] = offset
            seq['extent'] = (d.get_byte(), d.get_byte(), d.get_byte())
        else:
            seq['pixel_offset'] = (offset[0], offset[1])
        seq.update(read_sprite_layout_registers(d, flags, is_parent))
        sprites.append(seq)

    if basic_format:
        assert len(sprites) == 1, len(sprites)
        return [grf.BasicSpriteLayout(
            feature=feature,
            ref_id=ref_id,
            ground=ground,
            building=sprites[0],
        )]

    return [[grf.ExtendedSpriteLayout, grf.AdvancedSpriteLayout][has_flags](
        feature=feature,
        ref_id=ref_id,
        ground=ground,
        buildings=sprites,
    )]


VA2_GLOBALS = {
    0x00: ('date', 'W'),  # 80      W   current date (counted as days from 1920)[1]
    0x01: ('year', 'B'),  # 81      B   ￼0.6 ￼2.0   Current year (count from 1920, max. 2175 even with eternalgame)[1]
    0x02: ('month', 'B/D'),  # 82      B/D ￼0.6 ￼2.0   current month (0-11) in bits 0-7; the higher bytes contain unusable junk.[1] ￼0.7 ￼ Since OpenTTD r13594 'day of month' (0-30) is stored in bits 8-12, bit 15 is set in leapyears and 'day of year'(0-364 resp. 365) is stored in bits 16-24. All other bits are reserved and should be masked.
    0x03: ('climate', 'B'),  # 83      B   ￼0.6 ￼2.0   Current climate: 00 = temp, 01 = arctic, 02 = trop, 03 = toyland
                      # 84      D   ￼0.6 ￼2.0   GRF loading stage, see below
                      # 85      B   ￼0.6 ￼2.0   TTDPatch flags: only for bit tests
    0x06: ('drive_side', 'B'),  # 86      B   ￼0.6 ￼2.0   Road traffic side: bit 4 clear=left, set=right; other bits are reserved and must be masked. (87)    (87)    B   ￼ ￼ No longer used since TTDPatch 2.0. (was width of "€" character)
                      # 88      4*B   ￼0.6 ￼2.0   Checks specified GRFID (see condition-types)[2]
    0x09: ('date_fract', 'W'),  # 89      W   ￼0.6 ￼2.0   date fraction, incremented by 0x375 every engine tick
    0x0A: ('anim_counter', 'W'),  # 8A      W   ￼0.6 ￼2.0   animation counter, incremented every tick
    0x0B: ('ttdp_version', 'D'),  # 8B      D   ￼ ￼2.0  TTDPatch version, see below [3][4]
    0x0C: ('cur_cb_id', 'W'),  #         W   ￼0.6 ￼2.5   current callback ID (feature-specific), set to 00 when not in a callback
    0x0D: ('ttd_version', 'B'),  # 8D      B   ￼0.6 ￼2.5   TTD version, 0=DOS, 1=Windows
    0x0E: ('train_y_ofs', 'B'),  # 8E  8E  B   ￼0.6 ￼2.5   Y-Offset for train sprites
    0x0F: ('rail_cost', '3*B'),  # 8F  8F  3*B ￼0.6 ￼2.5   Rail track type cost factors
    0x10: ('cb_info1', 'D'),  #         D   ￼0.6 ￼2.5   Extra callback info 1, see below.
    0x11: ('cur_rail_tool', 'B'),  #         B   ￼ ￼2.5  current rail tool type (for station callbacks)
    0x12: ('game_mode', 'B'),  # 92      B   ￼0.6 ￼2.5   Game mode, 0 in title screen, 1 in game and 2 in editor
    0x13: ('tile_refresh_left', 'W'),  # 93  93  W   ￼ ￼2.5  Tile refresh offset to left [5]
    0x14: ('tile_refresh_right', 'W'),  # 94  94  W   ￼ ￼2.5  Tile refresh offset to right [5]
    0x15: ('tile_refresh_up', 'W'),  # 95  95  W   ￼ ￼2.5  Tile refresh offset upwards [5]
    0x16: ('tile_refresh_down', 'W'),  # 96  96  W   ￼ ￼2.5  Tile refresh offset downwards [5]
                      # 97  97  B   ￼ ￼2.5  Fixed snow line height [6][7]
    0x18: ('cb_info2', 'D'),  #         D   ￼0.6 ￼2.5   Extra callback info 2, see below.
                      # 99  99  D   ￼ ￼2.5  Global ID offset
    0x1A: ('max_uint32', 'D'),  # 9A      D   ￼0.6 ￼2.5   Has always all bits set; you can use this to make unconditional jumps
    0x1B: ('display_options', 'B'),  #         B   ￼ ￼2.5  display options; bit 0=town names, 1=station names, 2=signs, 3=animation, 4=transparency, 5=full detail
    0x1C: ('va2_ret', 'D'),  #         D   ￼0.6 ￼2.5   result from most recent VarAction2
    0x1D: ('ttd_platform', 'D'),  # 9D      D   ￼0.6 ￼2.5   TTD Platform, 0=TTDPatch, 1=OpenTTD [4]
    0x1E: ('grf_featuers', 'D'),  # 9E  9E  D   ￼0.6 ￼2.5   Misc. GRF Features
                      # 9F  D   ￼ ￼2.5  writable only: Locale-dependent settings
    0x20: ('snow_line', 'B'),  #         B   ￼0.6 ￼2.5   Current snow line height, FFh if snow isn't present at all [7]
    0x21: ('openttd_version', 'D'),  # A1      D   ￼0.6 ￼  OpenTTD version, see below. [4]
    0x22: ('difficulty_level', 'D'),  # A2      D   ￼0.7 ￼2.6   Difficulty level: 00= easy, 01=medium, 02=hard, 03=custom
    0x23: ('date_long', 'D'),  # A3      D   ￼0.7 ￼2.6   Current date long format
    0x24: ('year_zero', 'D'),  # A4      D   ￼0.7 ￼2.6   Current year zero based
    0x25: ('a3_grfid', 'D'),  #         D   ￼0.7 ￼  GRFID of the grf that contains the corresponding Action3. Useful when accessing the "related" object. Currently only supported for vehicles.
}

V2_OBJECT_VARS = {
    0x40: ('relative_pos', 'D'),  # Relative position, like Industry Tile var43
    0x41: ('tile_info', 'W'),  # Tile information, see below
    0x42: ('constructed', 'D'),  # Construction date from year 0
    0x43: ('anim_counter', 'B'),  # Animation counter, see below
    0x44: ('founder', 'B'),  # Object founder information
    0x45: ('closest_town_info', 'D'),  # Get town zone and Manhattan distance of closest town
    0x46: ('closest_town_dist_squared', 'D'),  # Get square of Euclidian distance of closest town
    0x47: ('colour', 'B'),  # Object colour
    0x48: ('views', 'B'),  # Object views
    0x60: ('type_view_ofs', 'W'),  # Get object type and view at offset
    0x61: ('random_ofs', 'B'),  # Get random bits at offset
    0x62: ('nearby_tile_info', 'D'),  # Land info of nearby tiles
    0x63: ('nearby_anim_counter', 'W'),  # Animation counter of nearby tile
    0x64: ('object_count', 'D'),  # Count of object, distance of closest instance
}

VA2_OP = {
    0x00: '+',  # \2+ result = val1 + val2    Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.52.5
    0x01: '-',  # \2- result = val1 - val2    Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.52.5
    0x02: 'min',  # \2< result = min(val1, val2)    Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.52.5    val1 and val2 are both considered signed
    0x03: 'max',  # \2> result = max(val1, val2)    Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.52.5
    0x04: 'min',  # \2u<    result = min(val1, val2)    Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.52.5    val1 and val2 are both considered unsigned
    0x05: 'max',  # \2u>    result = max(val1, val2)    Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.52.5
    0x06: '/',  #  \2/ result = val1 / val2    Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.52.5    val1 and val2 are both considered signed
    0x07: '%',  #  \2% result = val1 mod val2  Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.52.5
    0x08: 'u/',  #  \2u/    result = val1 / val2    Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.52.5    val1 and val2 are both considered unsigned
    0x09: 'u%',  #  \2u%    result = val1 mod val2  Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.52.5
    0x0A: '*',  #   \2* result = val1 * val2    Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.52.5    result will be truncated to B/W/D (that makes it the same for signed/unsigned operands)
    0x0B: '&',  #   \2& result = val1 & val2    Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.52.5    bitwise AND
    0x0C: '|',  #   \2| result = val1 | val2    Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.52.5    bitwise OR
    0x0D: '^',  #   \2^ result = val1 ^ val2    Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.52.5    bitwise XOR
    0x0E: '(tsto)',  #  \2s or \2sto [1]    var7D[val2] = val1, result = val1   Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.6 (r1246)2.6    Store result. See Temporary storage.
    0x0F: ';',  #   \2r or \2rst [1]    result = val2 [2]   Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.6 (r1246)2.6
    0x10: '(psto)',  #  \2psto [3]  var7C[val2] = val1, result = val1   Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.6 (r1315)2.6    Store result into persistent storage. See Persistent storage.
    0x11: '(ror)',  #  \2ror or \2rot [4]  result = val1 rotate right val2 Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.6 (r1651)2.6    Always a 32-bit rotation.
    0x12: '(cmp)',  #  \2cmp [3]   see notes   Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.6 (r1698)2.6    Result is 0 if val1<val2, 1 if val1=val2 and 2 if val1>val2. Both values are considered signed. [5]
    0x13: '(ucmp)',  #  \2ucmp [3]  see notes   Supported by OpenTTD 0.60.6 Supported by TTDPatch 2.6 (r1698)2.6    The same as 12, but operands are considered unsigned. [5]
    0x14: '<<',  #  \2<< [3]    result = val1 << val2   Supported by OpenTTD 1.1 (r20332)1.1 Supported by TTDPatch 2.6 (r2335)2.6   shift left; val2 should be in the range 0 to 31.
    0x15: 'u>>',  # \2u>> [3]   result = val1 >> val2   Supported by OpenTTD 1.1 (r20332)1.1 Supported by TTDPatch 2.6 (r2335)2.6   shift right (unsigned); val2 should be in the range 0 to 31.
    0x16: '>>',  #  \2>> [3]    result = val1 >> val2   Supported by OpenTTD 1.1 (r20332)1.1 Supported by TTDPatch 2.6 (r2335)2.6   shift right (signed); val2 should be in the range 0 to 31.
}


def get_va2_var(var):
    if var < 0x40:
        name, fmt = VA2_GLOBALS[var]
        return f'[{name}]', fmt
    if var == 0x5f: return '(random)', 'D'
    if var == 0x7b: return '(var_eval)', ''
    if var == 0x7c: return '(perm)', 'D'
    if var == 0x7d: return '(temp)', 'D'
    if var == 0x7e: return '(call)', 'D'
    if var == 0x7f: return '(param)', 'D'
    return V2_OBJECT_VARS[var]


def get_var_node(feature, root, var, param, shift, and_mask, node_type, add_val=None, divmod_val=None):
    if add_val is not None or divmod_val is not None:
        return grf.GenericVar(var, shift, and_mask, node_type, add_val, divmod_val, param=param)
    if var == 0x1a and shift == 0:
        return grf.Value(and_mask)

    if var == 0x7b:
        return get_var_node(feature, root, param.value, root, shift, and_mask, node_type, add_val, divmod_val)
    if (var, shift, and_mask) == (0x7c, 0, 0xffffffff):
        return grf.Perm(param)
    if (var, shift, and_mask) == (0x7d, 0, 0xffffffff):
        return grf.Temp(param)
    if (var, shift, and_mask) == (0x7e, 0, 0xffffffff):
        assert isinstance(param, grf.Value)
        return grf.Call(param.value)

    assert feature in VA2_VARS_INV, feature
    var_name = VA2_VARS_INV[feature].get((var, shift, and_mask))
    if var_name is not None:
        return grf.Var(feature, var_name, param=param)

    return grf.GenericVar(var, shift, and_mask, 0, None, None, param=param)


def decode_action2(data):
    feature = grf.Feature(data[0])
    ref_id = data[1]
    atype = data[2]
    d = DataReader(data, 3)

    # VarAction2
    if atype in (0x81, 0x82, 0x85, 0x86, 0x89, 0x8a):
        group_size = (atype >> 2) & 3
        related_scope = bool(atype & 2)
        first = True
        ofs = 3
        code = []
        accumulator = None
        while True:
            op = 0 if first else d.get_byte()
            var = d.get_byte()
            param = None
            if 0x60 <= var < 0x80:
                param = grf.Value(d.get_byte())
            varadj = d.get_byte()
            shift = varadj & 0x1f
            has_more = bool(varadj & 0x20)
            node_type = varadj >> 6
            and_mask = d.get_var(group_size)
            add_val = None
            divmod_val = None
            if node_type != 0:
                # old magic, use advaction2 instead
                add_val = d.get_var(group_size)
                divmod_val = d.get_var(group_size)

            node = get_var_node(feature, accumulator, var, param, shift, and_mask, node_type, add_val, divmod_val)

            if first:
                accumulator = node
            elif op == OP_INIT:
                if var != 0x7b:
                    code.append(accumulator)
                accumulator = node
            else:
                accumulator = grf.Expr(op, accumulator, node)

            first = False
            if not has_more:
                break

        code.append(accumulator)

        # no ranges is special for "do not switch, return the switch value"
        # <frosch123> oh, also, the ranges are unsigned
        # <frosch123> so if you want to set -5..5 you have to split into two ranges -5..-1, 0..5
        n_ranges = d.get_byte()
        ranges = []
        for _ in range(n_ranges):
            group = d.get_word()
            low = d.get_var(group_size)
            high = d.get_var(group_size)
            ranges.append(grf.Range(low, high, grf.Ref(group)))

        default_group = grf.Ref(d.get_word())

        for c in code:
            c.simplify()

        return [grf.VarAction2(
            feature=feature,
            ref_id=ref_id,
            related_scope=related_scope,
            ranges=ranges,
            default=default_group,
            code='\n'.join(x.format() for x in code),
        )]

    # Random switch
    if atype in (0x80, 0x83, 0x84):
        return []
        raise NotImplementedError

    if feature in (grf.HOUSE, grf.INDUSTRY_TILE, grf.OBJECT, grf.AIRPORT_TILE):
        num_ent1 = atype
        # if num_ent1 == 0:
        #     ground_sprite, building_sprite, xofs, yofs, xext, yext, zext = struct.unpack_from('<IIBBBBB', data, offset=3)
        #     ground_sprite = str_sprite(ground_sprite)
        #     building_sprite = str_sprite(building_sprite)
        #     return []

        # if 0 < num_ent1 <= 0x3f:
        #     raise NotImplementedError

        return read_sprite_layout(d, feature, ref_id, max(num_ent1, 1), num_ent1 == 0)
        # num_loaded = num_ent1
        # num_loading = get_byte()
        # [get_word() for i in range(num_loaded)]
        # [get_word() for i in range(num_loading)]
        # assert False, num_ent1
        # # assert num_ent1 < 0x3f + 0x40, num_ent1
        # return

    # Special Industry production callback format
    if feature == grf.INDUSTRY:
        version = atype
        if version < 2:
            getter = [d.get_word, d.get_byte][version]
            inputs = [getter(), getter(), getter()]
            outputs = [getter(), getter()]
        elif version == 2:
            num_input = d.get_byte()
            inputs = []
            for _ in range(num_input):
                inputs.append((d.get_byte(), d.get_byte()))
            num_output = d.get_byte()
            outputs = []
            for _ in range(num_output):
                outputs.append((d.get_byte(), d.get_byte()))
        else:
            raise NotImplementedError
        do_again = d.get_byte()
        return [grf.IndustryProductionCallback(
            inputs=inputs,
            outputs=outputs,
            do_again=do_again,
            version=version,
        )]


    # print('VA2', feature)
    # raise NotImplementedError
    num_ent1 = atype
    num_ent2 = data[3]
    # print('NE', num_ent2, feature)
    ent1 = struct.unpack_from('<' + 'H' * num_ent1, data, offset=4)
    ent2 = struct.unpack_from('<' + 'H' * num_ent2, data, offset=4 + 2 * num_ent1)
    # print(f'ent1:{ent1} ent2:{ent2}')
    return [grf.GenericSpriteLayout(
        feature=feature,
        ref_id=ref_id,
        ent1=ent1,
        ent2=ent2,
    )]


def decode_action3(data):
    feature = grf.Feature(data[0])
    idcount = data[1]
    wagon_override = bool(idcount & 0x80)
    if wagon_override:
        idcount &= 0x7f
    objs = []
    maps = []
    if data[1] == 0:
        _, default = struct.unpack_from('<BH', data, offset=2)
    else:
        d = DataReader(data, 2)
        objs = [d.get_extended_byte() for _ in range(idcount)]
        cidcount = d.get_byte()
        for _ in range(cidcount):
            ctype = d.get_byte()
            groupid = grf.Ref(d.get_word())
            maps.append({'ctype': ctype, 'groupid': groupid})
        default = d.get_word()
        # print(f'objs:{objs} maps:{maps} default_gid:{def_gid}')
    return [grf.Action3(
        feature=feature,
        ids=objs,
        maps=maps,
        default=grf.Ref(default),
    )]


def decode_action4(data):
    is_generic = bool(data[1] & 0x80)
    if is_generic:  # generic word offset flag
        fmt = '<BBBH'
    elif data[3] == 0xff and data[0] < 4:  # vehicles have extended byte offset
        fmt = '<BBBxH'
    else:  # default offset is byte
        fmt = '<BBBB'
    feature, lang, num, offset = struct.unpack_from(fmt, data)
    feature = grf.Feature(feature)

    str_data = data[struct.calcsize(fmt):-1]
    strings = [s for s in str_data.split(b'\0')] if str_data else []
    assert len(strings) == num, (len(strings), num,)
    return [grf.Action4(
        feature=feature,
        lang=lang & 0x7f,
        offset=offset,
        is_generic_offset=is_generic,
        strings=strings,
    )]


def decode_action5(data):
    t = data[0]
    offset = None
    num, dataofs = read_extended_byte(data, 1)
    if t & 0xf0:
        offset, _ = read_extended_byte(data, dataofs)
        t &= ~0xf0
    return [grf.ReplaceNewSprites(t, num, offset=offset)]


def decode_action6(data):
    d = DataReader(data, 0)
    params = []
    while True:
        param_num = d.get_byte()
        if param_num == 0xFF:
            break
        param_size = d.get_byte()
        offset = d.get_extended_byte()
        params.append({'num': param_num, 'size': param_size, 'offset': offset})
    return [grf.Action6(params)]


def decode_action7or9(data, is_static):
    variable = data[0]
    varsize = data[1]
    condition = data[2]
    value = 0
    for i in range(varsize):
        value = data[3 + i] * (1 << (8 * i))
    skip = data[3 + varsize]
    return [grf.If(
        is_static=is_static,
        variable=variable,
        varsize=varsize,
        condition=condition,
        value=value,
        skip=skip,
    )]


def decode_action7(data):
    return decode_action7or9(data, False)


def decode_action8(data):
    format_version = data[0]
    grfid = data[1: 5]
    pos = data.find(b'\0', 5)
    name = data[5: pos]
    description = data[pos + 1: -1]
    return [grf.SetDescription(
        grfid=grfid,
        name=name,
        description=description,
        format_version=format_version,
    )]


def decode_action9(data):
    return decode_action7or9(data, True)


def decode_actionA(data):
    num = data[0]
    sets = [struct.unpack_from('<BH', data, offset=3 * i + 1) for i in range(num)]
    return [grf.ReplaceOldSprites(sets)]


OPERATIONS = {
    0x00: '{target} = {source1}', # Supported by OpenTTD Supported by TTDPatch  Assignment  target = source1
    0x01: '{target} = {source1} + {source2}', # Supported by OpenTTD Supported by TTDPatch  Addition    target = source1 + source2
    0x02: '{target} = {source1} - {source2}', # Supported by OpenTTD Supported by TTDPatch  Subtraction     target = source1 - source2
    0x03: '{target} = {source1} * {source2} (Unsigned)', # Supported by OpenTTD Supported by TTDPatch  Unsigned multiplication     target = source1 * source2, with both sources being considered to be unsigned
    0x04: '{target} = {source1} * {source2} (Signed)', # Supported by OpenTTD Supported by TTDPatch  Signed multiplication   target = source1 * source2, with both sources considered signed
    0x05: '{target} = {source1} <</>> {source2} (Unsigned)', # Supported by OpenTTD Supported by TTDPatch  Unsigned bit shift  target = source1 << source2 if source2>0, or target = source1 >> abs(source2) if source2 < 0. source1 is considered to be unsigned
    0x06: '{target} = {source1} <</>> {source2} (Signed)', # Supported by OpenTTD Supported by TTDPatch  Signed bit shift    same as 05, but source1 is considered signed)
    0x07: '{target} = {source1} & {source2}', # Supported by OpenTTD Supported by TTDPatch 2.5 (alpha 48)2.5    Bitwise AND     target = source1 AND source2
    0x08: '{target} = {source1} | {source2}', # Suported by OpenTTD Supported by TTDPatch 2.5 (alpha 48)2.5    Bitwise OR  target = source1 OR source2
    0x09: '{target} = {source1} / {source2} (Unsigned)', # Supported by OpenTTD Supported by TTDPatch 2.5 (alpha 59)2.5    Unsigned division   target = source1 / source2
    0x0A: '{target} = {source1} / {source2} (Signed)', # Supported by OpenTTD Supported by TTDPatch 2.5 (alpha 59)2.5    Signed division     target = source1 / source2
    0x0B: '{target} = {source1} % {source2} (Unsigned)', # Supported by OpenTTD Supported by TTDPatch 2.5 (alpha 59)2.5    Unsigned modulo     target = source1 % source2
    0x0C: '{target} = {source1} % {source2} (Signed)', # Supported by OpenTTD Supported by TTDPatch 2.5 (alpha 59)2.5    Signed modulo   target = source1 % source2
}


def decode_actionC(data):
    return [grf.Comment(data)]


def decode_actionD(data):
    target = data[0]
    operation = data[1]
    if_undefined = bool(operation & 0x80)
    operation &= 0x7f
    source1 = data[2]
    source2 = data[3]
    if source1 == 0xff or source2 == 0xff:
        value, _ = read_dword(data, 4)
    fmt = OPERATIONS[operation]
    sf = lambda x: f'[{x:02x}]' if x != 0xff else str(value)
    target_str = f'[{target:02x}]'
    op_str = fmt.format(target=target_str, source1=sf(source1), source2=sf(source2))
    # print(f'    <A>OP {op_str}')
    # raise NotImplementedError
    return []


def decode_action10(data):
    label = data[0]
    comment = data[1:]
    return [grf.Action10(label, comment)]


def decode_action11(data):
    number, _ = read_word(data, 0)
    return [grf.SoundEffects(number)]


def decode_action14(data):
    res = {}
    ofs = 0

    def decode_chunk(res):
        nonlocal ofs
        chunk_type = data[ofs]
        ofs += 1
        if chunk_type == 0: return False
        chunk_id = data[ofs: ofs + 4]
        ofs += 4
        if chunk_type == b'C'[0]:
            res[chunk_id] = {}
            while decode_chunk(res[chunk_id]):
                pass
        elif chunk_type == b'B'[0]:
            l = data[ofs] | (data[ofs + 1] << 8)
            res[chunk_id] = data[ofs + 2: ofs + 2 + l]
            ofs += 2 + l
        elif chunk_type == b'T'[0]:
            lang = data[ofs]
            text_end = data.find(b'\0', ofs + 1)
            text = data[ofs + 1 : text_end]
            res[chunk_id] = (lang, text)
            ofs = text_end + 1
        else:
            assert False, chunk_type
        return True

    while decode_chunk(res):
        pass

    return [grf.SetProperties(res)]


def decode_actionFE(data):
    grfid = data[1:5]
    number, _ = read_word(data, 5)
    return [grf.ImportSound(grfid, number)]


ACTIONS = {
    0x00: decode_action0,
    0x01: decode_action1,
    0x02: decode_action2,
    0x03: decode_action3,
    0x04: decode_action4,
    0x05: decode_action5,
    0x06: decode_action6,
    0x07: decode_action7,
    0x08: decode_action8,
    0x09: decode_action9,
    0x0a: decode_actionA,
    0x0c: decode_actionC,
    0x0d: decode_actionD,
    0x10: decode_action10,
    0x11: decode_action11,
    0x14: decode_action14,
    0xfe: decode_actionFE,
}


class PyComment:
    def __init__(self, text):
        self.text = text

    def py(self):
        return f'# {self.text}'


def read_pseudo_sprite(f, nfo_line, container):
    data = f.read(2 if container == 1 else 4)

    # if not data and container == 1:
    #     return False, []
    l = struct.unpack('<H' if container == 1 else '<I', data)[0]
    if l == 0:
        return False, [PyComment('End of pseudo sprites')]
    grf_type = f.read(1)[0]
    grf_type_str = hex(grf_type)[2:]
    res = []
    if grf_type == 0xff:
        data = f.read(l)
        if l == 1:  # Some NewGRF files have "empty" pseudo-sprites which are 1 byte long.
            return True, []
        # print(f'{nfo_line}: Sprite({l}, {grf_type_str}) <{data[0]:02x}>: {hex_str(data, 100)}')
        res.append(PyComment(f'{nfo_line}: Sprite({l}, {grf_type_str}) <{data[0]:02x}>: {hex_str(data, 100)}'))
        decoder = ACTIONS.get(data[0])
        # TODO
        # <frosch123> _dp_: btw. when you get to it: a recolour sprite is not an action0 :p
        # <frosch123> action1/5/A tell you how many recolor/realsprite follow
        # <frosch123> there is no other reliable method to thell them apart
        # <frosch123> it's kind of the same for sounds
        # <frosch123> if you also want to support basesets, they have no action1/5/A, all pseudo sprites are recolor sprites
        if decoder:
            res.extend(decoder(data[1:]))
        else:
            res.append(PyComment(f'Unsupported action 0x{data[0]:02x}'))
    else:
        if container == 1:
            data = f.read(7)
            res.append(PyComment(f'{nfo_line}: Sprite({l}, {grf_type_str}): {hex_str(data, 100)}...'))
            decode_sprite(f, l - 8)
            return True, res
        else:
            data = f.read(l)
            res.append(PyComment(f'{nfo_line}: Sprite({l}, {grf_type_str}): {hex_str(data, 100)}'))
    return True, res


def decode_sprite(f, num):
    data = b''
    while num > 0:
        code = f.read(1)[0]
        if code >= 128: code -= 256
        # print(f'Code {code} num {num}')
        if code >= 0:
            size = 0x80 if code == 0 else code
            num -= size
            if num < 0: raise RuntimeError('Corrupt sprite')
            data += f.read(size)
        else:
            data_offset = ((code & 7) << 8) | f.read(1)[0]
            #if (dest - data_offset < dest_orig.get()) return WarnCorruptSprite(file, file_pos, __LINE__);
            size = -(code >> 3)
            num -= size
            if num < 0: raise RuntimeError('Corrupt sprite')
            data += data[-data_offset:size - data_offset]
    if num != 0: raise RuntimeError('Corrupt sprite')
    return data


def read_real_sprite(f, nfo_line):
    sprite_id = struct.unpack('<I', f.read(4))[0]
    if sprite_id == 0:
        return False, [PyComment('End of pseudo sprites')]
    num, t = struct.unpack('<IB', f.read(5))
    start_pos = f.tell()
    s = f'{nfo_line}: Real sprite({sprite_id}): ({num}, {t:02x}): '
    if t == 0xff:
        s += 'non-image'
        print('non-image:', sprite_id, num, t, hex_str(f.read(100)))
        f.seek(start_pos + num - 1, 0)
        return True, [PyComment(s)]
    zoom, height, width, x_offs, y_offs = struct.unpack('<BHHhh', f.read(9))
    fmt = ''
    if t & 0x01: fmt = fmt + 'RGB'
    if t & 0x02: fmt = fmt + 'A'
    if t & 0x04: fmt = fmt + 'M'
    bpp = len(fmt)
    decomp_size = struct.unpack('<I', f.read(4))[0] if t & 0x08 else width * height * bpp
    s += f'{fmt} {width}x{height} zoom={zoom} x_offs={x_offs} y_offs={y_offs} decomp_size={decomp_size}'
    # data = decode_sprite(f, decomp_size)
    # write_resource(f'sprite_{sprite_id}', 'dat', data)
    f.seek(start_pos + num - 1, 0)
    return True, [PyComment(s)]


filename = sys.argv[1]
with open(filename, 'rb') as f:
    first = f.read(1)
    container = None
    gen = grf.BaseNewGRF()
    comment = lambda text: gen.add(PyComment(text))
    if first == b'\00':
        header_bytes = first + f.read(9)
        comment(f'New container header: {hex_str(header_bytes)}')
        data_offest, compression = struct.unpack('<IB', f.read(5))
        header_offset = f.tell() - 1
        comment(f'Offset: {data_offest} compresion: {compression}')
        magic_sprite_bytes = f.read(5 + 4)
        comment(f'Magic sprite: {hex_str(magic_sprite_bytes)}')
        container = 2
    else:
        f.seek(0, 0)
        comment(f'Old container, no header!')
        container = 1
        magic_sprite_bytes = f.read(5 + 2)
        comment(f'Magic sprite: {hex_str(magic_sprite_bytes)}')

    # print('Magic sprite:', hex_str(f.read(4)))
    nfo_line = 1
    while (res := read_pseudo_sprite(f, nfo_line, container))[0]:
        gen.add(*res[1])
        nfo_line += 1

    if container == 2:
        real_data_offset = f.tell() - header_offset
        while (res := read_real_sprite(f, nfo_line))[0]:
            gen.add(*res[1])
            nfo_line += 1

        if data_offest != real_data_offset:
            comment(f'[ERROR] Data offset check failed: {data_offest} {real_data_offset}')

    print(f'# This file is generated by decompiling {filename} with grftopy.')
    print('# It\'s is only intended to be used as reference, don\'t expect it to actually run and produce grf.')
    print('')
    print(gen.generate_python())
